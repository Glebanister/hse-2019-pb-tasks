# Grep, итерация №2 (`task01-grep-updated`)

## Содержание

1. [Содержание](#содержание)
2. [Задание](#задание)
3. [Требования к корректности решения](#требования-к-корректности-решения)
   1. [Разумная попытка](#разумная-попытка)
   2. [Блокирующее](#блокирующее)
   3. [Режимы поиска](#режимы-поиска)
   4. [Режимы вывода](#режимы-вывода)
   5. [Прочие требования](#прочие-требования)
4. [Сдача задания](#сдача-задания)
   1. [Процесс](#процесс)
   2. [Сроки](#сроки)
   3. [Система оценки](#система-оценки)

## Задание
Добавьте к уже имеющейся реализации `grep.py` и `test.py` из задания `task01-grep` поддержку новых ключей.

Ключи, независимо друг от друга влияющие на понятие _найденной_ в файле строчки (похоже на ключ `-E`):

1. `-i` — игнорировать регистр символов при поиске совпадений (независимо от флага `-E`).
    * Для регулярных выражений рекомендуется использовать аргумент `flags=re.IGNORECASE` к функциям из библиотеки `re`.
    * Например, при этом ключе строка `hi` считается подстрокой строчки `hey HI world`, но не строчки `HeI`.
1. `-v` — инвертирует результат, то _найденные_ строки становятся _не найденными_ и наоборот.
1. `-x` — находит только полные совпадения вместо совпадений подстрок.
    * Если флаг `-E` отсутствует: строчки, в точности равные `needle`.
    * Если флаг `-E` присутствует: строчки, которые полностью подходят под регулярное выражение (используйте `re.fullmatch` вместо `re.search`).

Ключи, изменяющие формат вывода (похоже на ключ `-c`):

1. `-l` — выводить только имена файлов, в которых есть хотя бы одна _найденная_ строчка. Сами строчки не выводятся.
1. `-L` — выводить только имена файлов, в которых отсутствуют _найденные_ строчки. Сами строчки не выводятся.

## Требования к корректности решения
### Разумная попытка
Преподаватели в некоторых группах могут требовать сделать "разумную попытку" к определённому сроку.
Под этим понимается:

1. Все присланные файлы не имеют синтаксических ошибок.
2. Предоставленные в задании тесты проходят без их изменений при запуске команды `pytest`.
   Это также включает тесты, добавленные в этом задании (см. файл `test_grep_updated.py`).

### Блокирующее
Остаются все блокирующие требования с первой итерации, а также:

1. Файл `test_grep_updated.py` должен появиться в вашем решении и проходить все нужные автоматические проверки.
1. Все тесты на новые ключи должны располагаться в файле `test_grep_updated.py`.
1. Первый коммит в вашей ветке при сдаче через git в точности совпадает с вашим
   проверенным решением первой итерации.

### Режимы поиска
Поведение команд из первой итерации не меняется, только добавляются новые ключи.

Команда `./grep.py [-c|-l|-L] [-i] [-v] [-x] [-E] <needle> [<file> [<file>...]]` ищет в перечисленных файлах (или стандартном вводе, если файлов нет)
все строчки, в которых есть подстрока `<needle>`.
Эти строчки называются _найденными_ .
Для вывода ответа важно лишь то, считается ли строчка файла _найденной_ .

Ключи `-i`, `-v`, `-x` и `-E` могут встречаться в любых комбинациях и независимо влиять на то,
какие строчки считаются _найденными_ .

Ключи, кроме `-E`, можно склеивать: например, `-c -v -x` можно записать как `-cvx`.
Модуль `argparse` с этим автоматически разберётся.

### Режимы вывода
* По умолчанию на экран выводятся все _найденные_ строчки.
* Если файлов больше одного, то на экран выводится не просто _найденная_ строчка `<line>`, а ещё и имя файла: `<file>:<line>`.
* Ключ `-c` подавляет весь стандартный вывод утилиты и вместо этого выводит количество
  найденных строчек.
  Если файлов при этом больше одного, то на экран вместо суммарного количества строк
  выводится количество строчек отдельно для каждого файла в формате `<file>:<count>`.
* Ключ `-l` подавляет весь стандартный вывод утилиты и вместо этого выводит лишь имена файлов,
  в которых есть _найденные_ строчки.
* Ключ `-L` действует аналогично `-l`, но выводит лишь имена файлов, в которых нет найденных строчек.

Гарантируется, что ключи `-l`, `-L`, `-c` никогда не идут вместе, а также, что `-L` и `-l` не запускаются со стандартным вводом.

### Примеры
1. В режиме `./grep.py -livx -E fo?o a.txt b.txt` в файлах `a.txt` и `b.txt` будут найдены строчки,
   в точности равные `fo` или `foo` (без учёта регистра из-за ключа `-i`).
   На экран будут выведены имена файлов, в которых такие строки **не были** найдены (из-за ключа `-v`).
1. В режиме `./grep.py -civx -E fo?o a.txt b.txt` в файлах `a.txt` и `b.txt` будут найдены строчки,
   в точности равные `fo` или `foo` (без учёта регистра из-за ключа `-i`).
   На экран для каждого файла будет выведено количество строк, **не подходящих под это условие** (из-за ключа `-v`).

### Прочие требования
Остаются прочие требования из первой итерации.

## Сдача задания
### Процесс
Решением задачи являются три файла: `grep.py` с основным кодом решения, `test_grep.py`
с юнит- и интеграционными тестами ключей первой итерации, а также `test_grep_updated.py`
c юнит- и интеграционными тестами ключей второй итерации.
Не разрешается прикладывать другие файлы.

Для сдачи этого задания используется **только git**, причём появляется дополнительное требование:

1. Создайте fork репозитория `*-tasks` (если вы ещё не сделали этого).
1. В своём fork создайте ветку `task01-grep-updated-solution` на основе последнего коммита из ветки `master`.
1. В ветке `task01-grep-updated-solution` **ровно одним первым коммитом** добавьте вместо файлов `grep.py` и `test_grep.py` выполненную первую часть.
1. Выполните вторую часть создания.
1. Создайте Pull Request в ветку `master` репозитория `*-tasks` с нужным заголовком (`Task01-grep-updated, GroupXX, Фамилия Имя`)
   из ветки `task01-grep-updated-solution` вашего репозитория.
1. Убедитесь, что `@yeputons-bot` добавил к вашему PR метки, соответствующие
   номеру задания, номеру группы, а также `needs-grading` и назначил review
   на вашего преподавателя.

Последующие попытки:

1. Не помечайте комментарии преподавателя как `Resolved`, если об этом
   нет явной договорённости.
1. При желании ответьте на замечания преподавателя индивидуально.
1. Оставьте в PR отдельное сообщение, начинающееся со строчки
   `@yeputons-bot, исправлено.`
1. Убедитесь, что `@yeputons-bot` добавил к вашему PR метку `needs-grading`
   и назначил review на вашего преподавателя.

### Сроки
Сроки второй части будут у каждого свои. Уточняйте у своего преподавателя.

### Система оценки
Задание оценивается в 10 баллов (за две итерации), из них 4 вы получаете за корректность,
4 за стиль кода и тестов, и ещё 2 за субъективное качество тестов.

Если вы вообще не выполните вторую итерацию, вы можете получить за задание
не более 5 баллов из 10 возможных.

В каждой группе независимо устанавливаются баллы за посылки, сделанные
после срока сдачи, за частичное выполнение задания, за выполненную
первую итерацию без второй.
Уточняйте правила у своего преподавателя.
